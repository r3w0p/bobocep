Getting Started
***************


Complex Events
==============

The primary goal of :code:`bobocep` is to be able to infer the occurrence of *complex events* via patterns in data.
A simple example might be: a sharp rise in temperature sensor readings, followed by smoke detection, within 1 minute
of each other, could infer the occurrence of a **fire** in a physical environment.
When this happens, we notify an external system to start the fire alarms in the building.
Here, we define:

- A **pattern** that uses data and time correlations to infer the existence of a fire.
  The data can be considered **primitive** events that, when correlated using the pattern, form a **composite** event.
  A composite event can then be returned into the system for use in the pattern of another future composite event.

- A **name** for the composite event: "*fire*".

- **Actions** to take when the composite event is generated: starting the fire alarms.

The :code:`BoboComplexEvent` class is used to define complex events.
It requires a :code:`name`, a :code:`BoboPattern` instance for the pattern to detect, and a list of :code:`BoboAction`
instances to execute on composite event generation, in list order.
Data entering the system is encapsulated within :code:`PrimitiveEvent` instances, and :code:`CompositeEvent` instances
are generated on complex event detection, both of which are subclasses of the :code:`BoboEvent` type.


Architecture
============

.. figure:: _static/architecture.png
   :alt: Architecture

   The :code:`bobocep` architecture.

The four core subsystems of the architecture are as follows:

- **Receiver**.
  The entry point for data into the system. Its purpose is to validate incoming data and then format it into a
  *primitive event* using the :code:`PrimitiveEvent` class type.
  An instance of this type contains the incoming data, a unique identifier for the event, and a timestamp of when
  the event was created.

  - **Clock**. An internal clock generates timestamps for incoming events, which is the epoch time with nanosecond
    precision.

- **Decider**.
  Generates a *handler* for each complex event.
  :code:`BoboEvent` instances are consumed by this system and used to infer the existence of complex events.
  If a complex event has been detected, it will notify Producer.

  - **Rules**.
    Complex event definitions are passed to Decider, which are translated into
    `nondeterministic finite automata <https://en.wikipedia.org/wiki/Nondeterministic_finite_automaton>`_ (NFA).
    Instances of these automata, called *runs*, are created at runtime to reason on events and identify complex events.

- **Producer**.
  Receives notifications from Decider and generates a composite event on the presence of a complex event using the
  :code:`CompositeEvent` class type.
  These instances are forwarded to Forwarder, but can also be recursively sent back to Decider to be used to detect
  other complex events.
  Actions can be taken at this stage on event generation.

- **Forwarder**.
  Forwards :code:`CompositeEvent` instances to subscribers of Forwarder.
  This enables external systems to consume complex events generated by :code:`bobocep`.

These subsystems are inspired by the *information flow processing* (IFP) architecture proposed by Cugola et al.
[Cugola2012]_.
This architecture is extended by enabling Decider's functionality to be synchronised across multiple instances
of :code:`bobocep`.
This is accomplished using an external message broker to exchange updates in the state of partially-completed
complex events.


Quick Setup
===========

For a quick setup, we will create a :code:`BoboSetup` instance.

.. code:: python

    from bobocep.setup.bobo_setup import BoboSetup

    setup = BoboSetup()

Mandatory
---------

Complex Event Definitions
+++++++++++++++++++++++++

It is essential that the :code:`BoboSetup` contains *at least* one complex event definition.
We will define a simple pattern below, as follows.

.. code:: python

    from bobocep.rules.nfas.patterns.bobo_pattern import BoboPattern
    from bobocep.rules.predicates.windows.sliding.window_sliding_first import WindowSlidingFirst

    pattern_abc = BoboPattern() \
        .followed_by(label="data_a", predicate=lambda e, h: e.data == 'a') \
        .followed_by(label="data_b", predicate=lambda e, h: e.data == 'b') \
        .followed_by(label="data_c", predicate=lambda e, h: e.data == 'c') \
        .precondition(WindowSlidingFirst(interval_sec=10))

This pattern states that we need three events, where the data for the three events are :code:`'a'`, :code:`'b'`,
and :code:`'c'`, in that order.
All of these events must occur within 10 seconds.

Now, we add this pattern to our :code:`BoboSetup` instance with the name :code:`'abc'`, and no action to be taken if
it occurs.

.. code:: python

    from bobocep.setup.bobo_complex_event import BoboComplexEvent
    from bobocep.rules.actions.no_action import NoAction

    setup.add_complex_event(event_def=BoboComplexEvent(
        name='abc',
        pattern=pattern_abc,
        action=NoAction()))


Optional
--------

Receiver
++++++++

Firstly, we want to configure the Receiver by stating how incoming data should be **validated**. This ensures that
the data for :code:`PrimitiveEvents` have all been validated.
For example, we might want to ensure that all data are of type :code:`str` and are at least 5
characters in length.

.. code:: python

    from bobocep.receiver.validators.str_validator import StrValidator

    setup.config_receiver(StrValidator(min_length=5))

By default, all data will be accepted.


Producer
++++++++

An action can be performed on the Producer before the specific actions of any complex events are executed.
This action acts as a firewall.
That is, if the Producer's action returns :code:`False`, the :code:`CompositeEvent` in question will be
*dropped* and not passed to Forwarder.

For example, it might be desirable to *rate limit* :code:`CompositeEvent` instances.
If a :code:`CompositeEvent` with name "A" is being generated every 3 seconds, but you only want *at most*
1 of these events every 1 minute, we can do the following.

.. code:: python

    from bobocep.rules.actions.producer.rate_limit_action import RateLimitAction

    setup.config_producer(RateLimitAction({'A': 60}))

By default, no action is performed and all :code:`CompositeEvent` instances are accepted.


Forwarder
+++++++++

Similarly with Producer, the Forwarder is where you will send your :code:`CompositeEvent` instances beyond
:code:`bobocep`.
For this task, you will need to create your own `BoboAction` instance that will perform the tasks you require.
For example, a `BoboAction` that writes the events to file, or sends them to an external system.

.. code:: python

    setup.config_forwarder(my_action)


Distributed
+++++++++++

To connect to an external message broker and enable distributed complex event processing, you need to provide the
exchange name, host name, and user name associated with the message broker, as follows.

.. code:: python

    setup.config_distributed(
        exchange_name="my_exchange",
        user_name="my_user",
        host_name="192.168.1.123")


Null Data
+++++++++

It might be desirable to inject periodic data into the Receiver to ensure a continuous stream of events.
For example, if we want to inject an empty string :code:`""` into the system every 3 seconds,
we do the following.

.. code:: python

    setup.config_null_data(delay_sec=3, null_data="")


Run
---

Once we are happy with our configuration, we run the :code:`BoboSetup` as follows.

.. code:: python

    setup.run()

A :code:`RuntimeError` exception will be raised if there are any problems with the configuration.


Next Steps
==========

Now that we have set up a simple example, the next steps are to:

- Learn how to create your own `patterns <patterns.html>`_ for your own complex event definitions.
- Create some `actions <actions.html>`_ that you want to be executed on complex event generation.
- Add them to your :code:`BoboSetup` instance.


Why "Bobo"?
===========

Bobo is the name of Mr Burns' childhood teddy bear that features in the episode
"`Rosebud  <https://en.wikipedia.org/wiki/Rosebud_(The_Simpsons)>`_" of The Simpsons.
In the episode, Bobo goes on a long, perilous journey and, against all odds, manages to survive the adversity it faced.
:code:`bobocep` is designed to be distributed across the network edge and, thus, be resilient to adverse hardware and
software failures that affect its ability to provide service.
Therefore, I felt the name was very fitting.


References
==========

.. [Cugola2012]
    Cugola, G., & Margara, A. (2012).
    `Processing flows of information: From data stream to complex event processing
    <https://doi.org/10.1145/2187671.2187677>`_.
    *ACM Computing Surveys (CSUR)*, *44*\(3), 15.
